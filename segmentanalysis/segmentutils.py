# This module contains set of small service functions
import io
import re
import gzip

from segmentanalysis.typedef import DnaSequence, Genome

# from segmentanalysis.genomeinterval import GenomeInterval, strToBed


# === DNA sequence utilitites


def complement(sequence: DnaSequence) -> DnaSequence:
    """
    Make compliment of input sequence
    :param sequence: DNA sequence to make compliment
    :return: Compliment DNA sequence
    """
    base_complement = {"a": "t", "c": "g", "g": "c", "t": "a", "n": "n"}
    return "".join([base_complement[base] for base in sequence])


def revcomp(sequence: DnaSequence) -> DnaSequence:
    """
    Make reverse-compliment of input sequence
    :param sequence: DNA sequence to reverse-compliment
    :return: Reverse-compliment DNA sequence
    """
    return complement(sequence)[::-1]


# === IO fasta and bad read/write


def openMaybeGzipped(fileName: str) -> io.FileIO:
    """
    Determines whether input file is gzip-compressed and returns file handler via gzip / text file correspondingly
    :param fileName : Name of file to open
    :return: file handler to read lines
    """
    return (
        gzip.open(fileName, "rt") if fileName.endswith(".gz") else open(fileName, "r")
    )


def readList(filename: io.FileIO) -> list[str]:
    """
    Reads strings from file and returns it as a list
    filename: file name to read strings
    :return: list of strings read from file filename
    """
    return [line.strip() for line in open(filename).readlines()]


def readFasta(fastaFile: io.FileIO) -> Genome:
    """
    Reads genome from fasta file
    :param fastaFile : Input file to read sequences
    :return: dictionary {'chromosomeID':'ChromosomeSequence'}
    """
    genome = {}  # Dictionary of chromosomes
    chrId = ""
    chrSeq = []
    for line in fastaFile:
        if line[0] == ">":  # Next fasta record
            if chrId != "":  # Dumping current fast record
                genome[chrId] = "".join(chrSeq).lower()
            chrId = re.search(r">([-_A-z0-9]+)\s|$", line).group(
                1
            )  # Extracting new chromosome ID
            chrSeq = []
        else:
            chrSeq.append(line.strip())
    genome[chrId] = "".join(
        chrSeq
    ).lower()  # Adding to dictionary last readed chromosome
    return genome


def dumpFragmentsToFile(fragmentsFileName: str, fragmentsPositions):
    """
    Writes set of fragments to file
    dumpFile: file stream to write data
    fragmentsPositions: dictionary with fragments and positions generated by segmentsearch.searchFragments() function
    """
    fragmentsFile = open(fragmentsFileName, "w")
    for chromosome in fragmentsPositions.keys():
        sortedFragments = sorted(fragmentsPositions[chromosome].keys())
        for fragment in sortedFragments:
            fragmentString = "{}\t{:}\t{}\n".format(
                chromosome,
                fragment,
                ",".join([str(i) for i in fragmentsPositions[chromosome][fragment]]),
            )
            fragmentsFile.write(fragmentString)
    fragmentsFile.close()


def dumpCounts(
    countsFileName: str, nCounts, chunkSize, countsFormat="10d", skipZeros=False
):
    """
    writes calculated counts of fragments to text file
    :param countsFileName: name of file to write
    :param nCounts: dictionary containing normalized counts data from normalizeCounts function
    :param chunkSize:  size of one chunk
    """
    countsFile = open(countsFileName, "w")
    countsFormatter = "{0}\t{1}\t{2}\t{0}chunk{3}\t{4:" + countsFormat + "}\n"
    for chromosome in nCounts.keys():
        for chunk, nCount in enumerate(nCounts[chromosome]):
            if skipZeros and nCount == 0:
                continue
            start, stop = chunk * chunkSize, (chunk + 1) * chunkSize - 1

            countString = countsFormatter.format(chromosome, start, stop, chunk, nCount)
            countsFile.write(countString)
    countsFile.close()


def dumpCytoCouns(cytoCountsFileName, cytomap, cytoCounts):
    """
    Writes cytomap counts to BED file : cytobans genome coordinates, band ID and counts
    :param cytoCountsFileName: name of file to write
    :param cytomap: list of GenomeInterval objects representing cytomap
    :param cytoCounts: Numpy array of counts in the same order, as in cytomap list
    :return:
    """
    cytoCountsFile = open(cytoCountsFileName, "w")
    for i, interval in enumerate(cytomap):
        cytoCountsStr = "{}\t{}\t{}\t{}\t{}\n".format(
            interval.chromosome,
            interval.start,
            interval.stop,
            interval.name,
            cytoCounts[i],
        )
        cytoCountsFile.write(cytoCountsStr)


def isContainSubFragments(fragment, substrList):
    """
    Returns True if fragmnet contains at least one substring from substrList
    :param fragment: fragment sequence
    :param substrList: list of substrings to search
    :return: boolean search result
    """
    for s in substrList:
        if s in fragment:
            return True
    # Cycle ended and we haven't found anything
    return False


def isContainFragments(fragment, strList):
    """
    Returns True if fragmnet contains at least one substring from substrList
    :param fragment: fragment sequence
    :param substrList: list of substrings to search
    :return: boolean search result
    """
    for s1 in strList:
        if s1 == fragment:
            return True
    # Cycle ended and we haven't found anything
    return False
